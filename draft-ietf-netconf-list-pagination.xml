<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes" ?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-index="no" ?>
<!--<?rfc strict="no"?> -->

<rfc xmlns:xi="http://www.w3.org/2001/XInclude"
     docName="draft-ietf-netconf-list-pagination-latest"
     category="std"
     consensus="true"
     ipr="trust200902">

  <front>
    <title abbrev="List Pagination">
        List Pagination for YANG-driven Protocols
    </title>

    <author fullname="Kent Watsen" initials="K." surname="Watsen">
      <organization>Watsen Networks</organization>
      <address>
        <email>kent+ietf@watsen.net</email>
      </address>
    </author>
    <author fullname="Qin Wu" initials="Q." surname="Wu">
      <organization>Huawei Technologies</organization>
      <address>
        <email>bill.wu@huawei.com</email>
      </address>
    </author>
    <author fullname="Per Andersson" initials="P." surname="Andersson">
      <organization>Cisco Systems</organization>
      <address>
        <email>perander@cisco.com</email>
      </address>
    </author>
    <author fullname="Olof Hagsand" initials="O." surname="Hagsand">
      <organization>SUNET</organization>
      <address>
        <email>olof@hagsand.se</email>
      </address>
    </author>
    <author fullname="Hongwei Li" initials="H." surname="Li">
      <organization>Hewlett Packard Enterprise</organization>
      <address>
        <email>flycoolman@gmail.com</email>
      </address>
    </author>

    <date/>
    <area>OPS Area</area>
    <workgroup>NETCONF Working Group</workgroup>

    <abstract>
      <t>In some circumstances, instances of YANG modeled "list" and "leaf-list"
        nodes may contain numerous entries.  Retrieval of all the entries
        can lead to inefficiencies in the server, the client, and the network
        in between.</t>
      <t>This document defines a model for list pagination that can be
        implemented by YANG-driven management protocols such as NETCONF
        and RESTCONF.  The model supports paging over optionally filtered
        and/or sorted entries.  The solution additionally enables servers
        to constrain query expressions on some "config false" lists or
        leaf-lists.</t>
    </abstract>
  </front>
  <middle>
    <section anchor="intro" title="Introduction">

      <t>YANG modeled "list" and "leaf-list" nodes may contain a large
        number of entries.  For instance, there may be thousands of
        entries in the configuration for network interfaces or access
        control lists.  And time-driven logging mechanisms, such as an
        audit log or a traffic log, can contain millions of entries.</t>
      <t>Retrieval of all the entries can lead to inefficiencies in
        the server, the client, and the network in between.  For
        instance, consider the following:</t>
      <ul>
        <li>A client may need to filter and/or sort list entries in
          order to, e.g., present the view requested by a user.</li>
        <li>A server may need to iterate over many more list entries
          than needed by a client.</li>
        <li>A network may need to convey more data than needed by a
          client.</li>
      </ul>
      <t>Optimal global resource utilization is obtained when clients
        are able to cherry-pick just that which is needed to support
        the application-level business logic.</t>
      <t>This document defines a generic model for list pagination that can
        be implemented by YANG-driven management protocols such as NETCONF
        <xref target="RFC6241"/> and RESTCONF <xref target="RFC8040"/>.
        Details for how such protocols are updated are outside the scope
        of this document.</t>
      <t>The model presented in this document supports paging over
        optionally filtered and/or sorted entries.  Server-side filtering
        and sorting is ideal as servers can leverage indexes maintained
        by a backend storage layer to accelerate queries.</t>

      <section title="Terminology">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
          NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
          "MAY", and "OPTIONAL" in this document are to be interpreted as
          described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/>
          when, and only when, they appear in all capitals, as shown here.</t>
        <t>The following terms are defined in <xref target="RFC7950"/>
          and are not redefined here:
            client,
            data model,
            data tree,
            feature,
            extension,
            module,
            leaf,
            leaf-list,
            and server.
        </t>
        <!--
        <t>The following terms are defined in this document as follows:</t>
        -->
      </section>

      <section title="Conventions">
        <t>Various examples in this document use "BASE64VALUE=" as a
          placeholder value for binary data that has been base64
          encoded (per <xref section="9.8" target="RFC7950"/>).  This
          placeholder value is used because real base64 encoded structures
          are often many lines long and hence distracting to the example
          being presented.</t>
      </section>

      <section title="Adherence to the NMDA">
        <t>This document is compliant with the Network Management Datastore
          Architecture (NMDA) <xref target="RFC8342"/>.  The "ietf-list-pagination"
          module only defines a YANG extension and augments a couple leafs into a
          "config false" node defined by the "ietf-system-capabilities" module.</t>
      </section>

    </section>

    <section title="Solution Overview">
      <t>The solution presented in this document broadly entails
        a client sending a query to a server targeting a specific
        list or leaf-list including optional parameters guiding
        which entries should be returned.</t>
      <t>A secondary aspect of this solution entails a client
        sending a query parameter to a server guiding how
        descendent lists and leaf-lists should be returned.
        This parameter may be used on any target node, not
        just "list" and "leaf-list" nodes.</t>
      <t>Clients detect a server's support for list pagination
        via an entry for the "ietf-list-pagination" module (defined
        in <xref target="yang-module"/>) in the server's YANG
        Library <xref target="RFC8525"/> response.</t>
      <t>Relying on client-provided query parameters ensures
        servers remain backward compatible with legacy clients.</t>
    </section>

    <section title="Solution Details">
      <t>This section is composed of the following subsections:</t>
      <ul>
        <li><xref target="soln-sec-1"/> defines five query parameters
          clients may use to page through the entries of a single list
          or leaf-list in a data tree.</li>
        <li><xref target="soln-sec-2"/> defines one query
          parameter that clients may use to affect the content
          returned for descendant lists and leaf-lists.</li>
        <li><xref target="soln-sec-3"/> defines per schema-node tags
          enabling servers to indicate which "config false" lists
          are constrained and how they may be interacted with.</li>
      </ul>

      <section title="Query Parameters for a Targeted List or Leaf-List" anchor="soln-sec-1">
        <t>The five query parameters presented this section are listed in
          processing order.  This processing order is logical, efficient,
          and matches the processing order implemented by database systems,
          such as SQL.</t>
        <t>The order is as follows: a server first processes the "where" parameter
          (see <xref target="where"/>), then the "sort-by" parameter
          (see <xref target="sort-by"/>), then the "direction" parameter
          (see <xref target="direction"/>), and either a combination of
          the "offset" parameter (see <xref target="offset"/>) or the "cursor"
          parameter (see <xref target="cursor"/>), and lastly "the "limit"
          parameter (see <xref target="limit"/>).</t>
        <t>The sorting can furthermore be configured with a locale for
          collation. This is done by setting the "locale" parameter
          (see <xref target="locale"/>).</t>

        <section title='The "where" Query Parameter' anchor="where" toc="exclude">
          <dl newline="true">
            <dt>Description</dt>
            <dd>The "where" query parameter specifies a filter expression
              that result-set entries must match.</dd>

            <dt>Default Value</dt>
            <dd>If this query parameter is unspecified, then no entries are
              filtered from the working result-set.</dd>

            <dt>Allowed Values</dt>
            <dd>The allowed values are XPath 1.0 expressions.  It is an error
              if the XPath expression references a node identifier that does
              not exist in the schema, is optional or conditional in the schema
              or, for constrained "config false" lists and leaf-lists (see
              <xref target="soln-sec-3"/>), if the node identifier does not
              point to a node having the "indexed" extension statement
              applied to it (see <xref target="next-section"/>).</dd>

            <dt>Conformance</dt>
            <dd>The "where" query parameter MUST be supported for all "config
              true" lists and leaf-lists and SHOULD be supported for "config
              false" lists and leaf-lists.  Servers MAY disable the support
              for some or all "config false" lists and leaf-lists as described
              in <xref target="next-section"/>.</dd>
          </dl>
        </section>

        <section title='The "sort-by" Query Parameter' anchor="sort-by" toc="exclude">
          <dl newline="true">
            <dt>Description</dt>
            <dd>The "sort-by" query parameter indicates the node in the
              working result-set (i.e., after the "where" parameter has
              been applied) that entries should be sorted by.  Sorts are
              in ascending order (e.g., '1' before '9', 'a' before 'z',
              etc.).  Missing values are sorted to the end (e.g., after
              all nodes having values).  Sub-sorts are not supported.</dd>

            <dt>Default Value</dt>
            <dd>If this query parameter is unspecified, then the list or
              leaf-list's default order is used, per the YANG "ordered-by"
              statement (see <relref section="7.7.7" target="RFC7950"/>).</dd>

            <dt>Allowed Values</dt>
            <dd>The allowed values are node identifiers.  It is an error
              if the specified node identifier does not exist in the schema,
              is optional or conditional in the schema or, for constrained
              "config false" lists and leaf-lists (see <xref target="soln-sec-3"/>),
              if the node identifier does not point to a node having the "indexed"
              extension statement applied to it (see <xref target="next-section"/>).</dd>

            <dt>Conformance</dt>
            <dd>The "sort-by" query parameter MUST be supported for all "config
              true" lists and leaf-lists and SHOULD be supported for "config
              false" lists and leaf-lists.  Servers MAY disable the support
              for some or all "config false" lists and leaf-lists as described
              in <xref target="next-section"/>.</dd>
          </dl>
        </section>

        <section title='The "locale" Query Parameter'
            anchor="locale" toc="exclude">
          <dl newline="true">
            <dt>Description</dt>
            <dd>The "locale" query parameter indicates what
              locale is used when collating the result-set.</dd>

            <dt>Default Value</dt>
            <dd>If this query parameter is unspecified, it is up to the server
              select a locale for collation. How the server chooses the locale
              used is out of scope for this document. The result-set includes
              the locale used by the server for collation with a metadata value
              <xref target="RFC7952"/> called "locale".</dd>

            <dt>Allowed Values</dt>
            <dd>The format is a free form string but SHOULD follow the language
              sub-tag format defined in <xref target="RFC5646"/>. An example is
              'sv_SE'. If a supplied locale is unknown to the server, the
              "locale-unavailable" SHOULD be produced in the error-app-tag in
              the error output. Note that all locales are assumed to be UTF-8,
              since character encoding for YANG strings and all known YANG
              modelled encodings and protocols are required to be UTF-8
              <xref target="RFC6241"/> <xref target="RFC7950"/>
              <xref target="RFC7951"/> <xref target="RFC8040"/>. A server MUST
              accept a known encoding with or without trailing ".UTF-8" and MAY
              emit an encoding with or without trailing ".UTF-8". This means a
              server must handle both e.g. "sv_SE" and "sv_SE.UTF-8" equally
              as input, and chooses how to emit used locale as output.
            </dd>

            <dt>Conformance</dt>
            <dd>The "locale" query parameter MUST be supported for
              all "config true" lists and leaf-lists and SHOULD be supported
              for "config false" lists and leaf-lists. Servers MAY disable the
              support for some or all "config false" lists and leaf-lists as
              described in <xref target="next-section"/>.</dd>
          </dl>
        </section>

        <section title='The "direction" Query Parameter' anchor="direction" toc="exclude">
          <dl newline="true">
            <dt>Description</dt>
            <dd>The "direction" query parameter indicates how the entries
              in the working result-set (i.e., after the "sort-by" parameter
              has been applied) should be traversed.</dd>

            <dt>Default Value</dt>
            <dd>If this query parameter is unspecified, the default
              value is "forwards".</dd>

            <dt>Allowed Values</dt>
            <dd>The allowed values are:
              <dl newline="true">
                <dt>forwards</dt>
                <dd>Return entries in the forwards direction.  Also 
                  known as the "default" or "ascending" direction.</dd>
                <dt>backwards</dt>
                <dd>Return entries in the backwards direction.  Also
                  known as the "reverse" or "descending" direction</dd>
              </dl>
            </dd>

            <dt>Conformance</dt>
            <dd>The "direction" query parameter MUST be supported for
              all lists and leaf-lists.</dd>
          </dl>
        </section>

        <section title='The "offset" Query Parameter' anchor="offset" toc="exclude">
          <dl newline="true">
            <dt>Description</dt>
            <dd>The "offset" query parameter indicates the number of entries
              in the working result-set (i.e., after the "direction"
              parameter has been applied) that should be skipped over
              when preparing the response.</dd>

            <dt>Default Value</dt>
            <dd>If this query parameter is unspecified, then no entries
              in the result-set are skipped, same as when the offset
              value '0' is specified.</dd>

            <dt>Allowed Values</dt>
            <dd>The allowed values are unsigned integers.  It is an error
              for the offset value to exceed the number of entries in
              the working result-set, and the "offset-out-of-range" identity
              SHOULD be produced in the error-app-tag in the error output when
              this occurs.</dd>

            <dt>Conformance</dt>
            <dd>The "offset" query parameter MUST be supported for all
              lists and leaf-lists.</dd>
          </dl>
        </section>

        <section title='The "cursor" Query Parameter' anchor="cursor" toc="exclude">
          <dl newline="true">
            <dt>Description</dt>
            <dd>The "cursor" query parameter indicates where to start the
              working result-set (i.e., after the "direction" parameter has
              been applied), the elements before the cursor are skipped over
              when preparing the response. Furthermore, a result set constrained
              with the "limit" query parameter includes metadata values
              <xref target="RFC7952"/> called "next" and "previous", which
              contains cursor values to the next and previous result-sets.
              These next and previous cursor values are opaque index values for
              the underlying system's database, e.g. a key or other information
              needed to efficiently access the selected result-set. These "next"
              and "previous" metadata values work as Hypermedia as the Engine of
              Application State (HATEOAS) links
              <xref target="REST-Dissertation"/>. This means that the server
              does not keep any stateful information about the "next" and
              "previous" cursor or the current page. Due to their ephemeral
              nature, cursor values are never cached.</dd>

            <dt>Default Value</dt>
            <dd>If this query parameter is unspecified, then no entries
              in the result-set are skipped.</dd>

            <dt>Allowed Values</dt>
            <dd>The allowed values are base64 encoded positions interpreted by
              the server to index an element in the list, e.g. a list key or
              other information to efficiently access the selected result-set.
              It is an error to supply an unkown cursor for the working
              result-set, and the "cursor-not-found" identity SHOULD be produced
              in the error-app-tag in the error output when this occurs.</dd>

            <dt>Conformance</dt>
            <dd>
              <t>The "cursor" query parameter MUST be supported for all
              "config true" lists and SHOULD be supported for all "config false"
              lists. It is however optional to support the "cursor" query
              parameter for "config false" lists and the support must be
              signaled by the server per list.</t>

            <t>Servers indicate that they support the "cursor" query
              parameter for a "config false" list node by having the
              "cursor-supported" extension statement applied to it in the
              "per-node-capabilities" node in the "ietf-system-capabilities"
              model.</t>

            <t>Since leaf-lists might not have any unique values that can be
              indexed, the "cursor" query parameter is not relevant for the
              leaf-lists. Consider the following leaf-list [1,1,2,3,5], which
              contains elements without uniquely indexable values. It would be
              possible to use the position, but then the solution would be equal
              to using the "offset" query parameter.</t>
            </dd>
          </dl>
        </section>

        <section title='The "limit" Query Parameter' anchor="limit" toc="exclude">
          <dl newline="true">
            <dt>Description</dt>
            <dd>The "limit" query parameter limits the number of entries
              returned from the working result-set (i.e., after the "offset"
              parameter has been applied).  Any list or leaf-list that is
              limited includes, somewhere in its encoding, a metadata value
              <xref target="RFC7952"/> called "remaining", a positive integer
              indicating the number of elements that were not included in the
              result-set by the "limit" operation, or the value "unknown"
              in case, e.g., the server determines that counting would be
              prohibitively expensive.</dd>

            <dt>Default Value</dt>
            <dd>If this query parameter is unspecified, the number of
              entries that may be returned is unbounded.</dd>

            <dt>Allowed Values</dt>
            <dd>The allowed values are positive integers.</dd>

            <dt>Conformance</dt>
            <dd>The "limit" query parameter MUST be supported for
              all lists and leaf-lists.</dd>
          </dl>
        </section>
      </section>

      <section title="Query Parameter for Descendant Lists and Leaf-Lists" anchor="soln-sec-2">

        <t>Whilst this document primarily regards pagination for a
          list or leaf-list, it begs the question for how descendant
          lists and leaf-lists should be handled, which is addressed
          by the "sublist-limit" query parameter described in
          this section.</t>

        <section title='The "sublist-limit" Query Parameter' anchor="sublist-limit" toc="exclude">
          <dl newline="true">
            <dt>Description</dt>
            <dd>
              <t>The "sublist-limit" parameter limits the number of entries
                returned for descendent lists and leaf-lists.</t>
              <t>Any descendent list or leaf-list limited by the
                "sublist-limit" parameter includes, somewhere in its encoding,
                a metadata value <xref target="RFC7952"/> called "remaining",
                a positive integer indicating the number of elements that
                were not included by the "sublist-limit" parameter, or the
                value "unknown" in case, e.g., the server determines that
                counting would be prohibitively expensive.</t>
              <t>When used on a list node, it only affects the list's
                descendant nodes, not the list itself, which is only
                affected by the parameters presented in
                <xref target="soln-sec-1"/>.</t>
            </dd>

            <dt>Default Value</dt>
            <dd>If this query parameter is unspecified, the number of
              entries that may be returned for descendent lists and
              leaf-lists is unbounded.</dd>

            <dt>Allowed Values</dt>
            <dd>The allowed values are positive integers.</dd>

            <dt>Conformance</dt>
            <dd>The "sublist-limit" query parameter MUST be
              supported for all conventional nodes, including
              a datastore's top-level node (i.e., '/').</dd>
          </dl>
        </section>
      </section>

      <section title='Constraints on "where" and "sort-by" for "config false" Lists' anchor="soln-sec-3">
        <t>Some "config false" lists and leaf-lists may contain an
          enormous number of entries.  For instance, a time-driven
          logging mechanism, such as an audit log or a traffic log,
          can contain millions of entries.</t>
        <t>In such cases, "where" and "sort-by" expressions will
          not perform well if the server must bring each entry
          into memory in order to process it.</t>
        <t>The server's best option is to leverage query-optimizing
          features (e.g., indexes) built into the backend database
          holding the dataset.</t>
        <t>However, arbitrary "where" expressions and "sort-by"
          node identifiers into syntax supported by the backend
          database and/or query-optimizers may prove challenging,
          if not impossible, to implement.</t>
        <t>Thusly this section introduces mechanisms whereby a
          server can:</t>
        <ol>
          <li>Identify which "config false" lists and leaf-lists
            are constrained.</li>
          <li>Identify what node-identifiers and expressions are
            allowed for the constrained lists and leaf-lists.</li>
        </ol>
        <aside>
          <t>Note: The pagination performance for "config true" lists
            and leaf-lists is not considered as already servers must
            be able to process them as configuration.  Whilst some
            "config true' lists and leaf-lists may contain thousands
            of entries, they are well within the capability of
            server-side processing.</t>
        </aside>
        <section title='Identifying Constrained "config false" Lists and Leaf-Lists' anchor="prev-section">
          <t>Identification of which lists and leaf-lists are constrained
            occurs in the schema tree, not the data tree.  However, as
            server abilities vary, it is not possible to define constraints
            in YANG modules defining generic data models.</t>
          <t>In order to enable servers to identify which lists and leaf-lists
            are constrained, the solution presented in this document augments
            the data model defined by the "ietf-system-capabilities" module
            presented in <xref target="RFC9196"/>.</t>
          <t>Specifically, the "ietf-list-pagination" module (see <xref
            target="yang-module"/>) augments an empty leaf node called
            "constrained" into the "per-node-capabilities" node defined
            in the "ietf-system-capabilities" module.</t>
          <!-- FIXME: let servers augment-in a "constrained" extrension node instead? -->
          <t>The "constrained" leaf MAY be specified for any "config false"
            list or leaf-list.</t>
          <t>When a list or leaf-list is constrained:</t>
          <ul>
            <li>All parts of XPath 1.0 expressions are disabled unless
              explicitly enabled by <xref target="next-section"/>.</li>
            <li>Node-identifiers used in "where" expressions and "sort-by"
              filters MUST have the "indexed" leaf applied to it
              (see <xref target="next-section"/>).</li>
            <li>For lists only, node-identifiers used in "where" expressions
              and "sort-by" filters MUST NOT descend past any descendent lists.
              This ensures that only indexes relative to the targeted
              list are used.  Further constraints on node identifiers MAY
              be applied in <xref target="next-section"/>.</li>
          </ul>
        </section>
        <section title='Indicating the Constraints for "where" Filters and "sort-by" Expressions' anchor="next-section">
          <t>This section identifies how constraints for "where" filters and
            "sort-by" expressions are specified.  These constraints are valid
            only if the "constrained" leaf described in the previous section
            <xref target="prev-section"/> has been set on the immediate
            ancestor "list" node or, for "leaf-list" nodes, on itself.</t>
          <section title='Indicating Filterable/Sortable Nodes'>
            <t>For "where" filters, an unconstrained XPath expressions may
              use any node in comparisons.  However, efficient mappings to backend
              databases may support only a subset of the nodes.</t>
            <t>Similarly, for "sort-by" expressions, efficient sorts may
              only support a subset of the nodes.</t>
            <t>In order to enable servers to identify which nodes may be used in
              comparisons (for both "where" and "sort-by" expressions), the
              "ietf-list-pagination" module (see <xref target="yang-module"/>)
              augments an empty leaf node called "indexed" into the "per-node-capabilities"
              node defined in the "ietf-system-capabilities" module
              (see <xref target="RFC9196"/>).</t>
            <t>When a "list" or "leaf-list" node has the "constrained" leaf,
              only nodes having the "indexed" node may be used in "where" 
              and/or "sort-by" expressions.  If no nodes have the "indexed"
              leaf, when the "constrained" leaf is present, then "where" and
              "sort-by" expressions are disabled for that list or leaf-list.</t>
          </section>
        </section>
      </section>
    </section>


    <section title='The "ietf-list-pagination" Module' anchor="yang-module">
      <t>The "ietf-list-pagination" module is used by servers to indicate
        that they support pagination on YANG "list" and "leaf-list" nodes,
        and to provide an ability to indicate which "config false" list and/or
        "leaf-list" nodes are constrained and, if so, which nodes may be
        used in "where" and "sort-by" expressions.</t>
      <section title="Data Model Overview">
        <t>The following tree diagram <xref target="RFC8340"/> illustrates
          the "ietf-list-pagination" module:</t>
        <t>
          <figure>
           <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/tree-ietf-list-pagination.txt)
]]></artwork>
          </figure>
        </t>
        <t>Comments:</t>
        <ul>
          <li>As shown, this module augments three optional leafs into
            the "per-node-capabilities" node of the "ietf-system-capabilities"
            module.</li>
          <li>Not shown is that the module also defines an "md:annotation"
            statement named "remaining".  This annotation may be present
            in a server's response to a client request containing either
            the "limit" (<xref target="limit"/>) or "sublist-limit"
            parameters (<xref target="sublist-limit-param"/>).</li>
        </ul>
      </section>
      <section title="Example Usage">
        <section title='Constraining a "config false" list'>
          <t>The following example illustrates the "ietf-list-pagination"
            module's augmentations of the "system-capabilities" data tree.
            This example assumes the "example-social" module defined in
            the <xref target="example-social-module"/> is implemented.</t>
          <t>
            <figure>
             <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/ex-system-capabilities.xml)
]]></artwork>
            </figure>
          </t>
        </section>
        <section title='Indicating number remaining in a limited list'>
          <t>FIXME: valid syntax for 'where'?</t>
        </section>
      </section>
      <section title="YANG Module">
        <t>This YANG module has normative references to <xref target="RFC7952"/>
            and <xref target="RFC9196"/>.</t>
        <figure>
          <preamble>&lt;CODE BEGINS&gt; file "ietf-list-pagination@YYYY-MM-DD.yang"</preamble>
          <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(ietf-list-pagination@YYYY-MM-DD.yang)
]]></artwork>
          <postamble>&lt;CODE ENDS&gt;</postamble>
        </figure>
      </section>
    </section>

    <section title="IANA Considerations">

      <section title='The "IETF XML" Registry'>
        <t>This document registers one URI in the "ns" subregistry of
            the IETF XML Registry <xref target="RFC3688"/> maintained at
            <eref target="https://www.iana.org/assignments/xml-registry/xml-registry.xhtml#ns"/>.
            Following the format in <xref target="RFC3688"/>, the following
            registration is requested:</t>
        <t>
          <figure align="center">
            <artwork>
URI: urn:ietf:params:xml:ns:yang:ietf-list-pagination
Registrant Contact: The IESG.
XML: N/A, the requested URI is an XML namespace.
          </artwork>
          </figure>
        </t>
      </section>

      <section title='The "YANG Module Names" Registry'>
        <t>This document registers one YANG module in the YANG
          Module Names registry <xref target="RFC6020"/> maintained at
          <eref target="https://www.iana.org/assignments/yang-parameters/yang-parameters.xhtml"/>.
          Following the format defined in <xref target="RFC6020"/>,
          the below registration is requested:</t>
        <t>
          <figure align="center">
            <artwork>
name: ietf-list-pagination
namespace: urn:ietf:params:xml:ns:yang:ietf-list-pagination
prefix: lpg
RFC: XXXX
          </artwork>
          </figure>
        </t>
      </section>
    </section>

    <section anchor="security" title="Security Considerations">
      <section title='Considerations for the "ietf-list-pagination" YANG Module'>
        <t>This section follows the template defined in
          <xref section="3.7.1" target="RFC8407"/>.</t>

        <t>The YANG module specified in this document defines a schema for data
          that is designed to be accessed via network management protocols such
          as NETCONF <xref target="RFC6241"/> or RESTCONF
          <xref target="RFC8040"/>. The lowest NETCONF layer is the secure
          transport layer, and the mandatory-to-implement secure transport is
          Secure Shell (SSH) <xref target="RFC6242"/>. The lowest RESTCONF
          layer is HTTPS, and the mandatory-to-implement secure transport is TLS
          <xref target="RFC8446"/>.</t>

        <t>The Network Configuration Access Control Model (NACM)
          <xref target="RFC8341"/> provides the means to restrict access for
          particular NETCONF or RESTCONF users to a preconfigured subset of all
          available NETCONF or RESTCONF protocol operations and content.</t>

        <t>All protocol-accessible data nodes in this module are read-only and
          cannot be modified. Access control may be configured to avoid exposing
          any read-only data that is defined by the augmenting module
          documentation as being security sensitive.</t>

        <t>Since this module also defines groupings, these considerations are
          primarily for the designers of other modules that use these
          groupings.</t>

        <t>None of the readable data nodes defined in this YANG module are
          considered sensitive or vulnerable in network environments. The
          NACM "default-deny-all" extension has not been set for any data nodes
          defined in this module.</t>

        <t>This module does not define any RPCs or actions or notifications,
          and thus the security consideration for such is not provided here.</t>
      </section>
    </section>
  </middle>
  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.2119.xml"?> <!-- MUSTs, etc. -->
      <?rfc include="reference.RFC.3688.xml"?> <!-- IETF XML Registry -->
      <?rfc include="reference.RFC.5646.xml"?> <!-- Language sub-tags -->
      <?rfc include="reference.RFC.6241.xml"?> <!-- NETCONF -->
      <?rfc include="reference.RFC.6242.xml"?> <!-- NETCONF over SSH -->
      <?rfc include="reference.RFC.7950.xml"?> <!-- YANG (curr) -->
      <?rfc include="reference.RFC.7951.xml"?> <!-- YANG JSON encoding -->
      <?rfc include="reference.RFC.7952.xml"?> <!-- YANG Metadat -->
      <?rfc include="reference.RFC.8040.xml"?> <!-- RESTCONF -->
      <?rfc include="reference.RFC.8174.xml"?> <!-- rfc2119 update -->
      <?rfc include="reference.RFC.8341.xml"?> <!-- Network Configuration Access Control Model -->
      <?rfc include="reference.RFC.8407.xml"?> <!-- YANG review guidelines -->
      <?rfc include="reference.RFC.8446.xml"?> <!-- TLS 1.3 -->
      <?rfc include="reference.RFC.9196.xml"?> <!-- YANG Modules Describing Capabilities for Systems and Datastore Update Notifications -->
    </references>
    <references title="Informative References">
      <?rfc include="reference.RFC.6020.xml"?> <!-- YANG (orig) -->
      <?rfc include="reference.RFC.6365.xml"?> <!-- Internationalization -->
      <?rfc include="reference.RFC.8340.xml"?> <!-- YANG Tree Diagrams -->
      <?rfc include="reference.RFC.8342.xml"?> <!-- NMDA -->
      <?rfc include="reference.RFC.8525.xml"?> <!-- YANG Library -->
      <reference anchor="REST-Dissertation" quoteTitle="true"
          target="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">
        <front>
          <title>Architectural Styles and the Design of Network-based Software
            Architectures</title>
          <author initials="R." surname="Fielding" fullname="Rey Fielding"/>
          <date year="2000"/>
        </front>
      </reference>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-netconf-list-pagination-nc.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-netconf-list-pagination-rc.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-netconf-restconf-collection.xml"/>
    </references>

    <section title="Vector Tests">

      <t>This normative appendix section illustrates every notable
        edge condition conceived during this document's production.</t>
      <t>Test inputs and outputs are provided in a manner that is
        both generic and concise.</t>
      <t>Management protocol specific documents need only reproduce
        as many of these tests as necessary to convey pecularities
        presented by the protocol.</t>
      <t>Implementations are RECOMMENDED to implement the tests
        presented in this document, in addition to any tests that
        may be presented in protocol specific documents.</t>

      <section title="Example YANG Module" anchor="example-social-module">
        <t>The vector tests assume the "example-social" YANG module
          defined in this section.</t>
        <t>This module has been specially crafted to cover every
          notable edge condition, especially with regards to the
          types of the data nodes.</t>
        <t>Following is the tree diagram <xref target="RFC8340"/>
            for the "example-social" module:</t>
        <t>
          <figure>
            <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/tree-example-social.txt)
]]></artwork>
          </figure>
        </t>
        <t>Following is the YANG <xref target="RFC7950"/> for
          the "example-social" module:</t>
        <t>
          <figure>
            <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/example-social.yang)
]]></artwork>
          </figure>
        </t>
      </section>


      <section title="Example Data Set">
        <t>The examples assume the server's operational state
          as follows.</t>
        <t>The data is provided in JSON only for convenience and,
          in particular, has no bearing on the "generic" nature
          of the tests themselves.</t>
        <t>
          <figure>
            <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/ex-data-set.json)
]]></artwork>
          </figure>
        </t>
      </section>
  
  
      <section title="Example Queries">

        <t>The following sections are presented in reverse
          query-parameters processing order.  Starting with
          the simplest (limit) and ending with the most
          complex (where).</t>

        <t>All the vector tests are presented in a protocol-independent
          manner.  JSON is used only for its conciseness.</t>

        <section title='The "limit" Parameter'>

          <t>Noting that "limit" must be a positive number, the edge
            condition values are '1', '2', num-elements-1, num-elements,
            and num-elements+1.</t>

          <aside>
            <t>If '0' were a valid limit value, it would always
              return an empty result set.  Any value greater than or
              equal to num-elements results the entire result set,
              same as when "limit" is unspecified.</t>
          </aside>

          <t>These vector tests assume the target 
            "/example-social:members/member=alice/favorites/uint8-numbers",
            which has six values, thus the edge condition "limit" values
            are: '1', '2', '5', '6', and '7'.</t>

          <section title='limit=1'>
            <t>REQUEST</t>
            <t>
              <figure>
                <artwork><![CDATA[
Target: /example-social:members/member=alice/favorites/uint8-numbers
  Pagination Parameters:
    Where:     -
    Sort-by:   -
    Direction: -
    Offset:    -
    Limit:     1
]]></artwork>
              </figure>
            </t>
            <t>RESPONSE</t>
            <t>
              <figure>
                <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/ex-limit-1.json)
]]></artwork>
              </figure>
            </t>
          </section>

          <section title='limit=2'>
            <t>REQUEST</t>
            <t>
              <figure>
                <artwork><![CDATA[
Target: /example-social:members/member=alice/favorites/uint8-numbers
  Pagination Parameters:
    Where:     -
    Sort-by:   -
    Direction: -
    Offset:    -
    Limit:     2
]]></artwork>
              </figure>
            </t>
            <t>RESPONSE</t>
            <t>
              <figure>
                <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/ex-limit-2.json)
]]></artwork>
              </figure>
            </t>
          </section>

          <section title='limit=5'>
            <t>REQUEST</t>
            <t>
              <figure>
                <artwork><![CDATA[
Target: /example-social:members/member=alice/favorites/uint8-numbers
  Pagination Parameters:
    Where:     -
    Sort-by:   -
    Direction: -
    Offset:    -
    Limit:     5
]]></artwork>
              </figure>
            </t>
            <t>RESPONSE</t>
            <t>
              <figure>
                <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/ex-limit-5.json)
]]></artwork>
              </figure>
            </t>
          </section>

          <section title='limit=6'>
            <t>REQUEST</t>
            <t>
              <figure>
                <artwork><![CDATA[
Target: /example-social:members/member=alice/favorites/uint8-numbers
  Pagination Parameters:
    Where:     -
    Sort-by:   -
    Direction: -
    Offset:    -
    Limit:     6
]]></artwork>
              </figure>
            </t>
            <t>RESPONSE</t>
            <t>
              <figure>
                <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/ex-limit-6.json)
]]></artwork>
              </figure>
            </t>
          </section>

          <section title='limit=7'>
            <t>REQUEST</t>
            <t>
              <figure>
                <artwork><![CDATA[
Target: /example-social:members/member=alice/favorites/uint8-numbers
  Pagination Parameters:
    Where:     -
    Sort-by:   -
    Direction: -
    Offset:    -
    Limit:     7
]]></artwork>
              </figure>
            </t>
            <t>RESPONSE</t>
            <t>
              <figure>
                <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/ex-limit-7.json)
]]></artwork>
              </figure>
            </t>
          </section>

        </section>



        <section title='The "offset" Parameter'>

          <t>Noting that "offset" must be an unsigned number less than or
            equal to the num-elements, the edge condition values are '0', '1',
            '2', num-elements-1, num-elements, and num-elements+1.</t>

          <t>These vector tests again assume the target 
            "/example-social:members/member=alice/favorites/uint8-numbers",
            which has six values, thus the edge condition "limit" values
            are: '0', '1', '2', '5', '6', and '7'.</t>

          <section title='offset=0'>
            <t>REQUEST</t>
            <t>
              <figure>
                <artwork><![CDATA[
Target: /example-social:members/member=alice/favorites/uint8-numbers
  Pagination Parameters:
    Where:     -
    Sort-by:   -
    Direction: -
    Offset:    0
    Limit:     -
]]></artwork>
              </figure>
            </t>
            <t>RESPONSE</t>
            <t>
              <figure>
                <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/ex-offset-0.json)
]]></artwork>
              </figure>
            </t>
          </section>

          <section title='offset=1'>
            <t>REQUEST</t>
            <t>
              <figure>
                <artwork><![CDATA[
Target: /example-social:members/member=alice/favorites/uint8-numbers
  Pagination Parameters:
    Where:     -
    Sort-by:   -
    Direction: -
    Offset:    1
    Limit:     -
]]></artwork>
              </figure>
            </t>
            <t>RESPONSE</t>
            <t>
              <figure>
                <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/ex-offset-1.json)
]]></artwork>
              </figure>
            </t>
          </section>

          <section title='offset=2'>
            <t>REQUEST</t>
            <t>
              <figure>
                <artwork><![CDATA[
Target: /example-social:members/member=alice/favorites/uint8-numbers
  Pagination Parameters:
    Where:     -
    Sort-by:   -
    Direction: -
    Offset:    2
    Limit:     -
]]></artwork>
              </figure>
            </t>
            <t>RESPONSE</t>
            <t>
              <figure>
                <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/ex-offset-2.json)
]]></artwork>
              </figure>
            </t>
          </section>

          <section title='offset=5'>
            <t>REQUEST</t>
            <t>
              <figure>
                <artwork><![CDATA[
Target: /example-social:members/member=alice/favorites/uint8-numbers
  Pagination Parameters:
    Where:     -
    Sort-by:   -
    Direction: -
    Offset:    5
    Limit:     -
]]></artwork>
              </figure>
            </t>
            <t>RESPONSE</t>
            <t>
              <figure>
                <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/ex-offset-5.json)
]]></artwork>
              </figure>
            </t>
          </section>

          <section title='offset=6'>
            <t>REQUEST</t>
            <t>
              <figure>
                <artwork><![CDATA[
Target: /example-social:members/member=alice/favorites/uint8-numbers
  Pagination Parameters:
    Where:     -
    Sort-by:   -
    Direction: -
    Offset:    6
    Limit:     -
]]></artwork>
              </figure>
            </t>
            <t>RESPONSE</t>
            <t>
              <figure>
                <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/ex-offset-6.json)
]]></artwork>
              </figure>
            </t>
          </section>

          <section title='offset=7'>
            <t>REQUEST</t>
            <t>
              <figure>
                <artwork><![CDATA[
Target: /example-social:members/member=alice/favorites/uint8-numbers
  Pagination Parameters:
    Where:     -
    Sort-by:   -
    Direction: -
    Offset:    7
    Limit:     -
]]></artwork>
              </figure>
            </t>
            <t>RESPONSE</t>
            <t>
              <figure>
                <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/ex-offset-7.json)
]]></artwork>
              </figure>
            </t>
          </section>
        </section>



        <section title='The "cursor" Parameter'>
          <t>Noting that "cursor" must be an base64 encoded opaque value which
            addresses an element in a list.</t>

          <aside>
            <t>The default value is empty, which is the same as supplying
              the cursor value for the first element in the list.</t>
          </aside>

          <t>These vector tests assume the target 
              "/example-social:members/member" which has five members.</t>

          <aside>
            <t>Note that response has added attributes describing the result
              set and position in pagination.</t>
          </aside>

          <section title='cursor=&amp;limit=2'>
            <t>REQUEST</t>
            <t>
              <figure>
                <artwork><![CDATA[
Target: /example-social:members/member
  Pagination Parameters:
    Where:     -
    Sort-by:   -
    Direction: -
    Offset:    -
    Limit:     2
    Cursor:    -
]]></artwork>
              </figure>
            </t>
            <t>RESPONSE</t>
            <t>
              <figure>
                <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/ex-cursor-limit-2.json)
]]></artwork>
              </figure>
            </t>
          </section>

          <section title='cursor="YWxpY2U="&amp;limit=2'>
            <t>REQUEST</t>
            <t>
              <figure>
                <artwork><![CDATA[
Target: /example-social:members/member
  Pagination Parameters:
    Where:     -
    Sort-by:   -
    Direction: -
    Offset:    -
    Limit:     2
    Cursor:    YWxpY2U=
]]></artwork>
              </figure>
            </t>
            <t>RESPONSE</t>
            <t>
              <figure>
                <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/ex-cursor-alice-limit-2.json)
]]></artwork>
              </figure>
            </t>
          </section>

          <section title='cursor="am9l"&amp;limit=2'>
            <t>REQUEST</t>
            <t>
              <figure>
                <artwork><![CDATA[
Target: /example-social:members/member
  Pagination Parameters:
    Where:     -
    Sort-by:   -
    Direction: -
    Offset:    -
    Limit:     2
    Cursor:    am9l
]]></artwork>
              </figure>
            </t>
            <t>RESPONSE</t>
            <t>
              <figure>
                <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/ex-cursor-joe-limit-2.json)
]]></artwork>
              </figure>
            </t>
          </section>

        </section>



        <section title='The "direction" Parameter'>
          <t>Noting that "direction" is an enumeration with two values,
            the edge condition values are each defined enumeration.</t>

          <aside>
            <t>The value "forwards" is sometimes known as the "default"
              value, as it produces the same result set as when
              "direction" is unspecified.</t>
          </aside>

          <t>These vector tests again assume the target 
            "/example-social:members/member=alice/favorites/uint8-numbers".
            The number of elements is relevant to the edge condition values.</t>

          <aside>
            <t>It is notable that "uint8-numbers" is an "ordered-by" user
              leaf-list.  Traversals are over the user-specified order,
              not the numerically-sorted order, which is what the "sort-by"
              parameter addresses.  If this were an "ordered-by system"
              leaf-list, then the traversals would be over the system-specified
              order, again not a numerically-sorted order.</t>
          </aside>

          <section title='direction=forwards'>
            <t>REQUEST</t>
            <t>
              <figure>
                <artwork><![CDATA[
Target: /example-social:members/member=alice/favorites/uint8-numbers
  Pagination Parameters:
    Where:     -
    Sort-by:   -
    Direction: forwards
    Offset:    -
    Limit:     -
]]></artwork>
              </figure>
            </t>
            <t>RESPONSE</t>
            <t>
              <figure>
                <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/ex-direction-forwards.json)
]]></artwork>
              </figure>
            </t>
          </section>


          <section title='direction=backwards'>
            <t>REQUEST</t>
            <t>
              <figure>
                <artwork><![CDATA[
Target: /example-social:members/member=alice/favorites/uint8-numbers
  Pagination Parameters:
    Where:     -
    Sort-by:   -
    Direction: backwards
    Offset:    -
    Limit:     -
]]></artwork>
              </figure>
            </t>
            <t>RESPONSE</t>
            <t>
              <figure>
                <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/ex-direction-backwards.json)
]]></artwork>
              </figure>
            </t>
          </section>
        </section>



        <section title='The "sort-by" Parameter'>
          <t>Noting that the "sort-by" parameter is a node identifier,
            there is not so much "edge conditions" as there are "interesting
            conditions".  This section provides examples for some
            interesting conditions.</t>
          <section title="the target node's type">
            <t>The section provides three examples, one for a "leaf-list" and two
              for a "list", with one using a direct descendent and the other using
              an indirect descendent.</t>
            <section title='type is a "leaf-list"'>
              <t>This example illustrates when the target node's type is a "leaf-list".
                Note that a single period (i.e., '.') is used to represent the nodes
                to be sorted.</t>
              <t>This test again uses the target
                "/example-social:members/member=alice/favorites/uint8-numbers",
                which is a leaf-list.</t>
              <t>REQUEST</t>
              <t>
                <figure>
                  <artwork><![CDATA[
Target: /example-social:members/member=alice/favorites/uint8-numbers
  Pagination Parameters:
    Where:     -
    Sort-by:   .
    Direction: -
    Offset:    -
    Limit:     -
]]></artwork>
                </figure>
              </t>
              <t>RESPONSE</t>
              <t>
                <figure> <!-- 'ex-direction-backwards' just happens to be the right value -->
                  <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/ex-direction-backwards.json)
]]></artwork>
                </figure>
              </t>
            </section> <!-- leaf-list -->
            <section title='type is a "list" and sort-by node is a direct descendent'>
              <t>This example illustrates when the target node's type is a "list" and
                a direct descendent is the "sort-by" node.</t>
              <t>This vector test uses the target "/example-social:members/member",
                which is a "list", and the sort-by descendent node "member-id",
                which is the "key" for the list.</t>

              <t>REQUEST</t>
              <t>
                <figure>
                  <artwork><![CDATA[
Target: /example-social:members/member
  Pagination Parameters:
    Where:     -
    Sort-by:   member-id
    Direction: -
    Offset:    -
    Limit:     -
]]></artwork>
                </figure>
              </t>
              <t>RESPONSE</t>
              <aside>
                <t>To make the example more understandable, an ellipse (i.e., "...") is
                  used to represent a missing subtree of data.</t>
              </aside>
              <t>
                <figure>
                  <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/ex-sortby-list-direct.json)
]]></artwork>
                </figure>
              </t>
            </section> <!-- list and direct descendent -->
            <section title='type is a "list" and sort-by node is an indirect descendent'>
              <t>This example illustrates when the target node's type is a "list" and
                an indirect descendent is the "sort-by" node.</t>
              <t>This vector test uses the target "/example-social:members/member",
                which is a "list", and the sort-by descendent node "stats/joined",
                which is a "config false" descendent leaf.  Due to "joined" being
                a "config false" node, this request would have to target the
                "member" node in the &lt;operational&gt; datastore.</t>

              <t>REQUEST</t>
              <t>
                <figure>
                  <artwork><![CDATA[
Target: /example-social:members/member
  Pagination Parameters:
    Where:     -
    Sort-by:   stats/joined
    Direction: -
    Offset:    -
    Limit:     -
]]></artwork>
                </figure>
              </t>
              <t>RESPONSE</t>
              <aside>
                <t>To make the example more understandable, an elipse (i.e., "...") is
                  used to represent a missing subtree of data.</t>
              </aside>
              <t>
                <figure>
                  <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/ex-sortby-list-indirect.json)
]]></artwork>
                </figure>
              </t>
            </section> <!-- list and indirect descendent -->
          </section> <!-- target node's type -->

          <section title="handling missing entries">
            <t>The section provides one example for when the "sort-by"
              node is not present in the data set.</t>
            <t>FIXME: need to finish this section...</t>
          </section> <!-- handling missing entries -->

        </section> <!-- sort-by" parameter -->

        <section title='The "where" Parameter'>
          <t>The "where" is an XPath 1.0 expression, there are numerous
            edge conditions to consider, e.g., the types of the nodes
            that are targeted by the expression.</t>

          <section title="match of leaf-list's values">
            <t>FIXME</t>
          </section>

          <section title='match on descendent string containing a substring'>
            <t>This example selects members that have an email address containing "@example.com".</t>
            <t>REQUEST</t>
            <t>
              <figure>
                <artwork><![CDATA[
Target: /example-social:members/member
  Pagination Parameters:
    Where:     //.[contains (@email-address,'@example.com')]
    Sort-by:   -
    Direction: -
    Offset:    -
    Limit:     -
]]></artwork>
              </figure>
            </t>
            <t>RESPONSE</t>
            <aside>
              <t>To make the example more understandable, an elipse (i.e., "...") is
                used to represent a missing subtree of data.</t>
            </aside>
            <t>
              <figure>
                <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/ex-where-array-match-on-attribute.json)
]]></artwork>
              </figure>
            </t>
          </section>

          <section title='match on decendent timestamp starting with a substring'>
            <t>This example selects members that have a posting whose timestamp begins with the string "2020".</t>
            <t>REQUEST</t>
            <t>
              <figure>
                <artwork><![CDATA[
Target: /example-social:members/member
  Pagination Parameters:
    Where:     //posts//post[starts-with(@timestamp,'2020')]
    Sort-by:   -
    Direction: -
    Offset:    -
    Limit:     -
]]></artwork>
              </figure>
            </t>
            <t>RESPONSE</t>
            <aside>
              <t>To make the example more understandable, an elipse (i.e., "...") is
                used to represent a missing subtree of data.</t>
            </aside>
            <t>
              <figure>
                <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/ex-where-array-match-on-node-substring.json)
]]></artwork>
              </figure>
            </t>
          </section>

        </section>

        <section title='The "locale" Parameter' anchor="sort-locale-param">
          <t>The "locale" parameter may be used on any target node.</t>

          <aside><t>If this parameter is omitted, there is no default value it
            is up to the server chooses a locale. This locale is then reported
            in the result-set as the "locale" metadata value.</t>
            </aside>

            <t>REQUEST</t>
            <t>
              <figure>
                <artwork><![CDATA[
Target: /example-social:members/member
  Pagination Parameters:
    Where:     -
    Sort-by:   -
    Direction: -
    Offset:    -
    Limit:     -
    Sort-locale: sv_SE
]]></artwork>
              </figure>
            </t>
            <t>RESPONSE</t>
            <t>
              <figure>
                <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/ex-locale-list-1.json)
]]></artwork>
              </figure>
            </t>

            <t>REQUEST</t>
            <t>
              <figure>
                <artwork><![CDATA[
Target: /example-social:members/member
  Pagination Parameters:
    Where:     -
    Sort-by:   -
    Direction: -
    Offset:    -
    Limit:     -
    Sort-locale: en_US
]]></artwork>
              </figure>
            </t>
            <t>RESPONSE</t>
            <t>
              <figure>
                <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/ex-locale-list-2.json)
]]></artwork>
              </figure>
            </t>
        </section>


        <section title='The "sublist-limit" Parameter' anchor="sublist-limit-param">
          <t>The "sublist-limit" parameter may be used on any target node.</t>

          <section title='target is a list entry'>
            <t>This example uses the target node '/example-social:members/member=alice' in
              the &lt;intended&gt; datastore.</t>
            <aside><t>The target node is a specific list entry/element node, not the
              YANG "list" node.</t></aside>
            <t>This example sets the sublist-limit value '1', which returns just the
              first entry for all descendent lists and leaf-lists.</t>
            <t>Note that, in the response, the "remaining" metadata value is set on the 
              first element of each descendent list and leaf-list having more
              than one value.</t>
            <t>REQUEST</t>
            <t>
              <figure>
                <artwork><![CDATA[
  Datastore: <intended>
  Target: /example-social:members/member=alice
  Sublist-limit: 1
  Pagination Parameters:
    Where:     -
    Sort-by:   -
    Direction: -
    Offset:    -
    Limit:     -
]]></artwork>
              </figure>
            </t>
            <t>RESPONSE</t>
            <t>
              <figure>
                <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/ex-sublist-limit-target-list-entry.json)
]]></artwork>
              </figure>
            </t>
          </section>

          <section title='target is a datastore'>
            <t>This example uses the target node &lt;intended&gt;.</t>
            <t>This example sets the sublist-limit value '1', which returns just the
              first entry for all descendent lists and leaf-lists.</t>
            <t>Note that, in the response, the "remaining" metadata value is set on the 
              first element of each descendent list and leaf-list having more
              than one value.</t>
            <t>REQUEST</t>
            <t>
              <figure>
                <artwork><![CDATA[
  Datastore: <intended>
  Target: /
  Sublist-limit: 1
  Pagination Parameters:
    Where:     -
    Sort-by:   -
    Direction: -
    Offset:    -
    Limit:     -
]]></artwork>
              </figure>
            </t>
            <t>RESPONSE</t>
            <t>
              <figure>
                <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/ex-sublist-limit-target-datastore.json)
]]></artwork>
              </figure>
            </t>
          </section>
        </section> <!-- sublist-limit -->

        <section title='Combinations of Parameters'>

          <section title='All six parameters at once'>
            <!--
            <t>This example uses the target node '/example-social:members/member=alice' in
              the &lt;intended&gt; datastore.</t>
            <aside><t>The target node is a specific list entry/element node, not the
              YANG "list" node.</t></aside>
            <t>This example sets the sublist-limit value '1', which returns just the
              first entry for all descendent lists and leaf-lists.</t>
            <t>Note that, in the response, the "remaining" metadata value is set on the 
              first element of each descendent list and leaf-list having more
              than one value.</t>
            -->
            <t>REQUEST</t>
            <t>
              <figure>
                <artwork><![CDATA[
  Datastore: <operational>
  Target: /example-social:members/member
  Sublist-limit: 1
  Pagination Parameters:
    Where:     //stats//joined[starts-with(@timestamp,'2020')]
    Sort-by:   member-id
    Direction: backwards
    Offset:    2
    Limit:     2
]]></artwork>
              </figure>
            </t>
            <t>RESPONSE</t>
            <t>
              <figure>
                <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(includes/ex-param-combo-1.json)
]]></artwork>
              </figure>
            </t>
          </section>
        </section> <!-- uber examples -->


      </section> <!-- Example Queries -->

    </section> <!-- Vector Tests -->
  


    <!--
    <section title="Contributors" numbered="no">
      <figure>
      <artwork>
David Cornejo
dcornejo@gmail.com</artwork>
      </figure>
    </section>
    -->

    <section title="Acknowledgements" numbered="no">
      <t>The authors would like to thank the following for lively discussions on
      list (ordered by first name):
        Andy Bierman,
        Martin Bj&ouml;rklund,
        and
        Robert Varga.
      </t>
    </section>

  </back>
</rfc>
